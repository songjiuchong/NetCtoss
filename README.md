# NetCtoss



整体需求:

NETCTOSS项目分成3个子系统,用于解决电信行业Unix服务器出租业务的,共分为3个子系统:

1,DMS(采集端的部署); //负责对Unix服务器的日志进行分析的,从中采集出用户登录相关信息,并去访问一个固定的公共服务器将这些信息存储到同一的数据库中,这个系统要分别部署到不同的Unix服务器上;

注意:利用DMS系统而不是直接让NetCTOSS去读取Unix服务器上日志信息的原因是: <br/>
1)出于安全考虑,不想让各个Unix服务器将日志公开到一个公共的FTP上供NetCTOSS访问; <br/>
2)出于效率的考虑,让NetCTOSS去访问一个固定的服务器效率更高,而不是将DMS分配在固定的公共服务器上来抓取各个其他服务器的登录信息或是直接去访问各个服务器的日志信息;

2,NetCTOSS; //是个营业厅的营业员使用的,营业员可以通过这个系统创建Unix服务器用户,维护自费相关数据,资费的标准,查看用户的消费记录,需要独立部署到一台应用服务器上,需要读取同一的数据库的数据;

3,PL/SQL程序; //根据DMS采集的用户登录时长,以及NetCTOSS web系统维护的资费标准,自动地按时计算用户消费;


项目任务: <br/>
1,前提:资费模块; <br/>
2,目标:独立开发; <br/>
3,具体任务: <br/>
1)账务账号; <br/>
2)业务账号; <br/>
3)角色管理; <br/>
4)管理员;


技术架构: <br/>
1,所用技术:
Java+jdbc+struts2+Ajax/JQuery

2,开发思想:
基于MVC的分层思想,将代码分为以下层：

1)表现层: jsp页面,校验脚本,样式; <br/>
2)控制层: struts2; <br/>
3.1)业务层: Action中,业务控制代码; <br/>
3.2)数据访问层: jdbc+dao;


具体开发: <br/>
1,账务账号; <br/>
1)带条件的组合查询; <br/>
2)新增,修改; <br/>
3)删除; 并非物理删除,而是执行更新语句,将status字段改为2; <br/>
4)状态的维护;

2,带条件的组合查询;
1) 规划代码: <br/>
    a,页面: account/findAccount.jsp <br/>
	b,struts.xml: 配置账务账号模块,查询的Action; <br/>
	c,FindAccountAction; <br/>
	   输入,输出属性是相对页面而言的,当前操作需要页面传递什么参数,那么这些参数就是输入属性;
	   当前操作需要返回给页面什么值,那么这些值就是输出属性;
	   
	d,IAccountDao; <br/>
	f, AccountDaoImpl; <br/>
	e,实体类Account;
	
2) 写代码: <br/>
	a,写实体类; (之后的Action,dao都要用到,需要先了解表结构) <br/>
	b,struts xml; (Action,jsp规划好) <br/>
	c,Action:  相对于需要给访问者提供怎样的html页面,页面中怎么返回给Action更新后的参数; <br/>
	定义输入属性; 需要jsp提供的参数; <br/>
	定义输出属性; 需要返回给jsp的值; <br/>
	d,dao:包括接口,实现类,工厂类; <br/>
	e,jsp页面,根据美工提供的静态页面来改; <br/>
	包括:struts标签,js脚本;
	
	
2,开通,暂停,删除状态管理; <br/>
a,当列表中某行的状态为开通时,显示暂停,修改,删除按钮; <br/>
b,当列表中某行的状态为暂停时,显示开通,修改,删除按钮; <br/>
c,当列表中某行的状态为删除时,不显示任何按钮;

开通; <br/>
操作暂停状态的数据,点击开通后,这行数据的状态置0,删除暂停时间;
重新开通账务账号时不需要将其下所属所有业务账号重新开通,需要按需求逐个重新开通;

暂停; <br/>
操作开通状态的数据,点击暂停后,这行数据的状态置1,记录暂停时间;
同时暂停其下属所有的业务账号(暂时不做,业务账号模块还未完成);

删除; <br/>
操作的是开通/暂停状态的数据,点击删除后,这行数据的状态置2,记录删除时间;
删除账务账号,同时删除其下所属的所有业务账号(暂时不做,业务账号模块还未完成);

状态维护的思路; <br/>
a,通过js脚本来提交请求(异步),包含id参数; <br/>
b,Action中请求找到对应的Action,Action,会调用对应的dao方法,根据id更新状态和日期的字段; <br/>
c,更新状态结束后,显示提示信息给用户; <br/>
d,更新当前的列表页面,将更新后的字段以及其按钮更新,停留在当前页,所以需要将page传出;


新增; <br/>
推荐人:填完推荐人身份证号之后,光标切换时,发送异步请求(传递推荐人身份证号参数),查询表中是否
存在该推荐人,如果存在返回id,将id记录在隐藏的dom中,其name="recommenderId";
提交时会将这个id给recommenderId属性;如果不存在提示此用户不存在;

生日:不可编辑,需要通过身份证号计算的来;当填写完身份证号时,光标切换时,从身份证号中截取出生日,填给生日字段;

修改; <br/>
1.参考自费模块的修改功能; <br/>
2.页面的校验和新增一致; <br/>
3.修改密码:填写完旧密码,光标切换时,发异步请求(传递id和旧密码),检查当前输入的旧密码是否正确,如果不正确不能修改,正确才能修改;


查看明细; <br/>
1.列表中,姓名上加超链接,URL指定为查看的Action(viewAccountAction),转到查看页面; <br/>
2.创建查看的页面(viewAccount.jsp);Action中根据输入属性id,查询这条记录(参考toUpdateCost的查询方法),
转发到viewAccount.jsp,并将查询结果输出给页面;明细的所有字段都是只读的,没有保存按钮,只有返回;



业务帐号; <br/>
业务说明:用于创建和维护登录Unix服务器的帐号密码,以及维护登录藏好的状态;

1,账务账号和业务帐号之间是1对多的关系,在业务装好中要记录账务账号信息;<br/>
2,一对多的关系体现在SERVICE表中的ACCOUNT_ID字段;<br/>
3,创建业务帐号时,要指定资费类型(从资费管理取),业务帐号表中存的是资费表的ID;

组合查询:
1,逻辑上和账务账号一致;<br/>
2,查询结果中不再是账务账号这一张表的数据,还包含业务帐号表中的身份证,姓名,以及资费表中的资费名,资费描述,这些字段需要关联查询出来;<br/>
3,用VO来封装多张表联合查询的结果;view object,视图对象,用来获取所需视图的实体类;

状态维护:
1,开通,暂停,删除状态的维护和账务账号一致;<br/>
2,开通有区别;<br/>
在开通的时候,先判断对应的账务账号是否处于暂停/删除的状态,如果是的话,不能开通,并且提示用户;<br/>
在开通的Action的execute方法中:
//输入属性;
private Integer id;<br/>
private Integer accountId;<br/>
private boolean pass; <br/>
privateString message; //提示信息;

public String execute(){<br/>
	拿到dao;<br/>
	//1,判断对应的账务账号是否暂停/删除;<br/>
	Account a = dao.findAccountById(accountId);<br/>
	if(a.getStatus().equals("1")||a.getStatus().equals("2")){<br/>
		pass = false;<br/>
		message = "对应的账务账号已暂停或删除,不能进行此项操作";<br/>
		return "success";<br/>
	}<br/>
	//调用dao的开通方法去开通...和账务账号开通方法相同;
}


新增:<br/>
1,基本思路和账务账号一样;<br/>
2,输入完身份证点击查询账务账号时,异步发请求,根据身份证查询账务账号表,得到账务账号的数据返回页面,页面判断返回结果是否为空,若为空则提示重新输入,并清空隐藏的accountId和账务账号显示,若不为空则设置隐藏的accountId和账务账号;<br/>
这里的账务账号对应的是账务账号表的登录名(loginName);<br/>
3,资费类型:<br/>
数据来源于资费列表中的所有数据,该下拉选的option的value对应资费表的id字段,option的显示内容对应的是资费表的名称字段;


修改:<br/>
1,资费类型下拉选动态构建参考新增;<br/>
2,其他的参考账务账号修改;


业务说明:<br/>
1,点击站务账号暂停按钮,要将账务账号数据暂停;<br/>
之后,要根据当前的账务账号ID,从业务账号表中根据ACCOUNT_ID字段将相关的业务账号更新状态为暂停;<br/>
同时将暂停时间设置为当前系统时间;<br/>
2,点击账务账号删除按钮,要将账务账号数据删除,之后要根据当前的账务账号ID,从业务账号表中根据ACCOUNT_ID字段将相关的业务账号更新状态为删除;<br/>
同时将删除时间设置为当前系统时间;

暂停下属业务账号;<br/>
1,写一个方法,根据账务账号ID,查询相关的业务账号数据;<br/>
2,循环这组业务账号数据,每次调用之前的根据业务账号ID更改相关状态的方法;<br/>
pauseService(int id);但是这种方法效率低,需要避免;<br/>
3,可以重载pauseService(int[] id);<br/>
4,重构pauseService(int id),改成pauseService(int[] id);<br/>
调用dao.pauseService(new int[]{id});


查看明细;<br/>
1,参考账务账号的查看明细,或者参考资费管理的修改;

补充:<br/>
如果页面上要显示的日期字段进行存储,那么注意一下几点:<br/>
1)数据库中的类型是日期类型;<br/>
2)实体对象中的类型为字符串;<br/>
3)查询语句中对日期类型的字段to_char;<br/>
4)插入/更新语句中对日期类型的字段to_date;

持久化日期字段(新增账务账号中根据身份证获得生日);<br/>
1,数据库中是日期类型;<br/>
2,实体类中是String类型;<br/>
3,insert into account values(to_date(?,'yyyy-mm-dd'));<br/>
4,select to_char(BIRTHDAY,'yyyy-mm-dd') birthday from ACCOUNT;

一般不在DAO中做事务处理,而是在业务层(action)做事务处理,之后在spring中会讲;


备注:<br/>
2个瓶颈:<br/>
1,杜绝在循环内发请求,因为前端发送请求非常耗费资源,并且无法预知循环次数;<br/>
2,尽量杜绝在循环内访问数据库,因为访问数据库也很耗资源,无法预知循环次数的时候,效率无法控制;



权限控制;

业务说明：<br/>
1，权限控制：软件具有若干功能（模块：一组功能的集合）；<br/>
在使用时，不是所有的用户都能使用其中所有的功能，是要给用户指定一定的权限，该权限包含了他能访问的功能；<br/>
分配权限和权限控制的过程叫权限控制；

2，权限控制分为：<br/>
1）权限设置；<br/>
a,设置角色<br/>
b,设置角色能操作的功能<br/>
角色和功能之间是一对多的关系；<br/>
c,设置用户（关联角色，从而间接关联功能）；<br/>
当一个用户具有多个角色的时候，那么他具有的功能权限是这些角色所具有的功能的并集；

2）权限检查；<br/>
a,动态的构建导航栏；<br/>
b,给Action加拦截器，判断是否具有权限；

3，NETCTOSS权限设置体系：<br/>
由角色管理，管理员管理组成的；

角色管理：<br/>
1，表说明：<br/>
ROLE_INFO:角色表，只存角色信息；<br/>
ROLE_PRIVILEGE:角色权限表，存的是角色和权限的关联关系；<br/>
一个是角色表的ID，一个是privileges.xml中privilege的ID；<br/>
privileges.xml:存的是权限相关的数据，每个privilege描述了能够访问哪些功能；

2,新增:<br/>
1)新增角色信息;<br/>
2)从刚新增的角色信息中取得自动生成的ID;<br/>
3)根据取得的ID,以及传递进来的权限ID数组,批量的保存角色权限数据;

3,修改:<br/>
1)修改角色信息;<br/>
2)删除该角色所有的角色权限数据;<br/>
3)根据传入的角色权限数据,重新新增角色权限数据;


findRole 分页sql;

select * from ROLE r inner join ROLE_PRIVILEGE p on i.ID=p.ROLE_ID<br/>
where i.id in(<br/>
	.....<br/>
)



管理员模块:<br/>
1,用来维护登陆NETCTOSS系统用户的登陆信息;<br/>
包含组合查询,新增,修改,删除,密码重置等功能;<br/>
2,查询:带条件的组合查询;<br/>
1)角色查询条件改成下拉选,选择范围为所有的角色;

2)组合查询:<br/>
select * from ADMIN_INFO ai <br/>
inner join ADMIN_ROLE ar on ai.ID = ar.ADMIN_ID<br/>
inner join ROLE ri on ri.ID = ar.ROLE_ID<br/>
inner join ROLE_PRIVILEGE rp on rp.ROLE_ID = ri.ID<br/>
where 1=1<br/>
and......


密码重置:<br/>
1)将选中的行,对应的用户的密码重置为默认密码(123456);<br/>
2)由于查询页面上没有显示密码列,那么操作完密码重置之后，就没有必要刷新页面,因此需要异步的提交请求;<br/>
3)主要是JS操作;


新增:<br/>
1)在新增的页面上,通过<s:checkboxlist/>标记来生成角色的数据;<br/>
2)新增DAO的步骤<br/>
a,插入管理员的数据admin_info;<br/>
b,把上面插入数据自动生成的ID得到;<br/>
c,根据得到的ID以及传递进来的一组角色ID来插入管理员角色的数据;


修改:<br/>
1)将管理员信息更新<br/>
2)删除管理员角色信息(根据管理员ID)<br/>
3)重新将管理员角色信息加入;


删除:<br/>
参考;


项目内容概括:

项目描述;<br/>
1)NETCTOSS项目,这个项目汉族要用来针对电信Unix服务器出租业务中,出租账号,资费维护,收取费用的相关业务的管理;<br/>
2)该项目分为3个子系统:

DMS:用来提取用户登录Unix服务器的信息的;<br/>
通过读取服务器的日志文件,将登录信息读取出来之后写入到NETCTOSS统一的数据库中,需要每一台Unix服务器都单独部署DMS;

NETCTOSS WEB系统:用来维护登录Unix服务器的账户的,以及用来维护用户的资费标准,查看用户的消费情况(账单管理,报表);<br/>
包含了如下模块:<br/>
角色管理,管理员,资费管理,账务账号,业务账号,账单管理,报表;<br/>
我主要负责开发其中的角色管理,管理员,资费管理,账务账号,业务账号;

该系统的技术架构:<br/>
Java+JDBC+Struts2+jsp+javascript/jquery

介绍模块,比如:<br/>
账务账号:该模块用于维护向用户收费的账号,该账号与业务账号具有一对多的关系,业务账号是客户登录Unix服务器的账号;<br/>
具有新增,修改,删除,组合查询,状态维护,查看明细的功能;<br/>
重点阐述组合查询,状态维护,新增(页面校验);

数据库存储过程:<br/>
每月固定时间(月底)自动计算用户本月消费情况,根据DMS提取的登录时长,NETCTOSS系统中维护的资费数据来进行计算;<br/>
这些PL/SQL的脚本需要部署到NETCTOSS的数据库上,并且为存储过程定义好任务(何时触发);<br/>
计算好的数据可以在NETCTOSS WEB系统中查看;



备注:
1,通过<include file=""></include>
的方式可以拆分一个大的struts.xml文件来重构该配置文件,使代码可读性提高;
 
*/
